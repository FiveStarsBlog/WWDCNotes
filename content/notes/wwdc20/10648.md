---
contributors: dasauto
---
## `Unsafe` and `Safe`
* The distinction between safe and unsafe constructs is the way their implementations deal with the invalid input.
* Most operations in the standard library fully validate their input before executing.
* **Safe** operations have **well-defined** behavior on **all** input.
* **Unsafe** operations have **undefined** behavior on **some** input.
* Force unwrap operator is **safe** because we can fully describe its behavior for all possible inputs.
* Optional provides an **unsafe** force-unwrapping operation through its `unsafelyUnwrapped` property. This property does **not** verify the underlying value to be non-nil.
* By using `unsafe` property you assume full responsibility to fulfill its requirements.

```swift
// Optional's force unwrapping operator

let value: Int? = nil

print(value!) // Fatal error: Unexpectedly found nil while unwrapping an Optional value
```

```swift
// Unsafe force-unwrapping

let value: String? = "Hello"

print(value.unsafelyUnwrapped) // Hello
```

```swift
// Invalid use of unsafe force-unwrapping

let value: String? = nil

print(value.unsafelyUnwrapped) // Guaranteed fatal error in debug builds
```

### Benefits of `unsafe` interfaces
* Interoperability with code written in C or Objective-C.
* Control over runtime performance.

### Safe code â‰  no crashes
* Safe APIs guarantee to stop execution by raising a fatal runtime error.
* Swift is a safe programming language means its language and library-level features fully validate their input.

## Unsafe Pointers
* Unsafe pointer types are roughly on the same level of abstraction as pointers in the C programming language.

> Treat it as a C pointer. Think about `malloc()`, `calloc()`, `free()`, how C treats an array and array arithmetic in C. 
> 
> The following notes will assume you understand pointers in C.

### Memory
![][memory]
> This picture shows memory from lower memory address (top) to higher memory address (bottom).

* Swift has a flat memory model.
* A linear address space of individually addressable 8-bit bytes (64-bit).
* Memory address is a hexadecimal integer value.
* As app executes, the state of its memory keeps evolving.

### Example
Manual memory management:

```swift
let ptr = UnsafeMutablePointer<Int>.allocate(capacity: 1)
ptr.initialize(to: 42)
print(ptr.pointee) // 42
ptr.deallocate()
ptr.pointee = 23 // UNDEFINED BEHAVIOR
```
* Allocating an `UnsafeMutablePointer<Int>` creates a storage location and gives back a pointer to it.
* Pointer gets invalidated as the underlying memory is deinitialized and deallocated.
* `ptr.pointee` is dereferencing pointer `ptr`.
* Dereferencing a `NULL` pointer is a serious programming error.
* Xcode provides Address Sanitizer to help you catch memory corruption errors.
* For more, refer to [Safely manage pointers in Swift](https://developer.apple.com/videos/play/wwdc2020/10167/) session.

![][address_sanitizer]


[memory]: ../../../images/notes/wwdc20/10648/memory.png
[address_sanitizer]: ../../../images/notes/wwdc20/10648/address_sanitizer.png