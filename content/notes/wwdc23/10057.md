---
contributors: srujanc
---

# Unleash the UIKit trait system

Discover powerful enhancements to the trait system in UIKit. Learn how you can define custom traits to add your own data to UITraitCollection, modify the data propagated to view controllers and views with trait override APIs, and adopt APIs to improve flexibility and performance. We'll also show you how to bridge UIKit traits with SwiftUI environment keys to seamlessly access data from both UIKit and SwiftUI components in your app.

> UIKit traits with SwiftUI environment keys to seamlessly pass data between UIKit and SwiftUI components in your app. Traits are independent pieces of data that the system automatically propagates to every view controller and view in your app. UIKit provides many built-in system traits, such as user interface style, horizontal size class, and preferred content size category. 

> In iOS 17, you can define your own custom traits as well. This unlocks a powerful new way for you to provide data to your app's view controllers and views. The main way that you work with traits in UIKit is using trait collections. A trait collection contains traits and their associated values. There are some new APIs in iOS 17 that make it easier to work with trait collections. 

. First, there is a new initializer that takes a closure. Inside that closure, you receive a mutable traits container that you can set values to. This mutable container conforms to a new protocol named UIMutableTraits. 
. Inside the closure, I set the user interface idiom to phone and the horizontal size class to regular. When the closure finishes executing, the initializer returns an immutable UITraitCollection instance that contains all of the trait values inside the closure. 
. There’s also a new modifyingTraits method that allows you to create a new instance by modifying values from the original trait collection inside the closure.
. While you can create your own trait collections like this, most of the time you obtain trait collections from trait environments. 


Trait environments in your app are window scenes, windows, presentation controllers, view controllers, and views. Every one of these trait environments has its own trait collection, and each trait collection may contain different values. Trait environments are connected in the trait hierarchy, which is how traits flow through your app. 

Here's an example of the trait hierarchy’s tree structure, from each window scene all the way down to the individual view controllers and views. Each trait environment inherits trait values from its parent environment. Always use the trait collection of the most specific trait environment possible. 


```swift

    // Build a new trait collection instance from scratch
        let myTraits = UITraitCollection { mutableTraits in
            mutableTraits.userInterfaceIdiom = .phone
            mutableTraits.horizontalSizeClass = .regular
        }

    // Get a new instance by modifying traits of an existing one
        let otherTraits = myTraits.modifyingTraits { mutableTraits in
            mutableTraits.horizontalSizeClass = .compact
            mutableTraits.userInterfaceStyle = .dark
        }

```

Here is an example of a parent view controller, which contains a child view controller. The dashed line represents the view controller hierarchy. The parent controller owns a view, and the solid line connecting them represents their relationship. The parent view has one subview, and the dashed line through the views represents the view hierarchy. Finally, the view of the child controller is a subview of that middle view. And views owned by a view controller inherited their traits directly from their view controller. Finally, views without a view controller inherited traits directly from their superview. This behavior meant that the flow of traits in the view hierarchy stopped at each view owned by a view controller. 


[!Example] For example, A trait value from the view of the parent controller would only be inherited by its direct subview. The view of the child controller wouldn’t receive that value, even though it is a subview in the view hierarchy below those views. This behavior could be surprising. In iOS 17, we’ve eliminated this issue by unifying the trait hierarchy for view controllers and views. View controllers now inherit their trait collection from their view’s superview, instead of directly from their parent view controller. This creates a simple linear flow of traits through view controllers and views. Note how view controllers still inherit traits from their parent view controller, it just happens indirectly via the views in between them. 

Because view controllers now inherit their traits from the view hierarchy, a view controller’s view must be in the hierarchy for the view controller to receive updated traits. As a result, if you access a view controller’s trait collection before its view has been added to the hierarchy, the view controller won’t have up-to-date values for its traits. The most common place you might find code that is affected is inside viewWillAppear, as that is always called before the view has been added to the hierarchy. 

There's a new callback named viewIsAppearing that you can use instead. viewIsAppearing is called after viewWillAppear once the view has been added to the hierarchy and both the view controller and view have up-to-date trait collections. viewIsAppearing is a drop-in replacement for nearly all cases where you’re using viewWillAppear today. And the best part is that this new method back-deploys all the way to iOS 13. 

Watch **"What’s New In UIKit"** to learn more about this new callback and how it fits into the view controller life cycle. iOS 17 also improves the consistency and performance for view trait updates. 

> Views only update their trait collection when they are in the hierarchy. And once in the hierarchy, each view only updates its trait collection immediately before it performs layout. The best practice is to use traits during layout. 

> For views, that means using the traitCollection from inside the layoutSubviews method. 


[!Remember] Remeber that layoutSubviews runs again any time setNeedsLayout is called on the view, so your implementation should avoid duplicating work if called multiple times. 

## Custom traits

Custom traits are a powerful new feature in iOS 17. 

> They open up an entirely new way for you to provide data to your view controllers and views. As you work with data in your app, consider the following things to help you decide when to define a new custom trait. Traits are a great choice when you need to propagate data to many children, such as from a parent view controller to multiple child view controllers or from a superview to all of its subviews. You can also use traits to pass data to other components that may be nested many layers deep, where you don’t have a direct connection to them. Because traits are inherited through the hierarchy, they can provide context to your views and view controllers about their environment, such as providing information about a containing view controller. While the trait system is powerful, using it to propagate data is not free. 


> For best performance, use traits when they add value, but avoid using traits when you can easily pass data directly. Now you're ready to define your first custom trait.

```swift

// Implementing a custom theme trait

enum MyAppTheme: Int {
    case standard, pastel, bold, monochrome
}

struct MyAppThemeTrait: UITraitDefinition {
    static let defaultValue = MyAppTheme.standard
    static let affectsColorAppearance = true
    static let name = "Theme"
    static let identifier = "com.myapp.theme"
}

extension UITraitCollection {
    var myAppTheme: MyAppTheme { self[MyAppThemeTrait.self] }
}

extension UIMutableTraits {
    var myAppTheme: MyAppTheme {
        get { self[MyAppThemeTrait.self] }
        set { self[MyAppThemeTrait.self] = newValue }
    }
}


// Using a custom theme trait

let customBackgroundColor = UIColor { traitCollection in
    switch traitCollection.myAppTheme {
    case .standard:    return UIColor(named: "StandardBackground")!
    case .pastel:      return UIColor(named: "PastelBackground")!
    case .bold:        return UIColor(named: "BoldBackground")!
    case .monochrome:  return UIColor(named: "MonochromeBackground")!
    }
}

let view = UIView()
view.backgroundColor = customBackgroundColor

```

## Managing trait overrides

Here are some performance considerations to keep in mind as you use trait overrides. 

* First, each trait override has a small cost, so only set trait overrides on the places you need them and avoid setting trait overrides that aren’t used. 
* And every time you change a trait override, the system needs to update the trait collection of any descendants in the hierarchy. Therefore, minimize the number of times that you change trait overrides. 
* Finally, trait overrides applied near the root of the hierarchy, such as on the window scene or window, affect everything beneath them. This is very useful, and there are many great use cases for applying trait overrides to the window scene or window. 

> However, when a trait only affects a few views deep in the hierarchy, then apply the trait override to the nearest common ancestor of those views instead, such as a common superview or a view controller. That way, you aren’t paying the cost of propagating the trait to your entire hierarchy when only a small portion of the hierarchy uses that data. Now that you know how to define traits and populate data for them in the hierarchy, you need to handle when they change value.

```swift

func toggleThemeOverride(_ overrideTheme: MyAppTheme) {
    if view.traitOverrides.contains(MyAppThemeTrait.self) {
        // There's an existing theme override; remove it
        view.traitOverrides.remove(MyAppThemeTrait.self)
    } else {
        // There's no existing theme override; apply one
        view.traitOverrides.myAppTheme = overrideTheme
    }
}

```

## Implementing a bridged UIKit trait and SwiftUI environment key

Assuming a custom trait in UIKit and a custom environment key in SwiftUI that represent the same data, all you need to do to bridge them is add a conformance to the UITraitBridgedEnvironmentKey protocol. 


> To do this, we implement one method to read the trait from UIKit and return the value to SwiftUI, and one method to write the SwiftUI environment value to the UIKit trait. And now both the UIKit trait and SwiftUI environment key access unified storage, so now we can read or write to the same data from components written using either framework. 

> At the root of an app, apply a trait override for the theme trait onto the UIKit window scene. This propagates the monochrome theme value to everything contained inside that window scene. 

> Then, deeper down inside of a window in that window scene, we have a UIKit collection view. This collection view contains cells, which are configured using UIHostingConfiguration, to display a SwiftUI view in each cell. Inside the SwiftUI CellView, we have a property named "theme," which uses the Environment property wrapper to read the value from the SwiftUI environment. The value in the environment corresponds to the same value for the bridged trait in UIKit. And finally, We use the theme property to control the color of text inside this SwiftUI view. Because SwiftUI automatically tracks data dependencies, if the theme trait override all the way up on the UIKit window scene changes to a different value.

```swift

enum MyAppTheme: Int {
    case standard, pastel, bold, monochrome
}

// Custom UIKit trait
struct MyAppThemeTrait: UITraitDefinition {
    static let defaultValue = MyAppTheme.standard
    static let affectsColorAppearance = true
}

extension UITraitCollection {
    var myAppTheme: MyAppTheme { self[MyAppThemeTrait.self] }
}

extension UIMutableTraits {
    var myAppTheme: MyAppTheme {
        get { self[MyAppThemeTrait.self] }
        set { self[MyAppThemeTrait.self] = newValue }
    }
}

// Custom SwiftUI environment key
struct MyAppThemeKey: EnvironmentKey {
    static let defaultValue = MyAppTheme.standard
}

extension EnvironmentValues {
    var myAppTheme: MyAppTheme {
        get { self[MyAppThemeKey.self] }
        set { self[MyAppThemeKey.self] = newValue }
    }
}

// Bridge SwiftUI environment key with UIKit trait
extension MyAppThemeKey: UITraitBridgedEnvironmentKey {
    static func read(from traitCollection: UITraitCollection) -> MyAppTheme {
        traitCollection.myAppTheme
    }

    static func write(to mutableTraits: inout UIMutableTraits, value: MyAppTheme) {
        mutableTraits.myAppTheme = value
    }
}

```

Now that you've learned about these powerful new features, go and find places in your app where you can leverage the trait system to automatically propagate data by defining your own custom traits. 

Next, adopt the new traitOverrides property to easily modify data in the trait hierarchy. And then use the more flexible trait registration APIs to create precise dependencies on the exact traits you use. Finally, bridge your custom UIKit traits with custom SwiftUI environment keys so that your data flows seamlessly between UIKit and SwiftUI components in your app.
